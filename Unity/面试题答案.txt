一、请简述值类型与引用类型的区别,其实各自的基类

区别：
1、值类型通常被分配在栈上，它的变量直接包含变量的实例，使用效率比较高。
2、引用类型分配在托管堆上，引用类型的变量通常包含一个指向实例的指针，变量通过该指针来引用实例。
3、值类型继承自ValueType（注意：而System.ValueType又继承自System.Object）；而引用类型继承自System.Object。 
4、值类型变量包含其实例数据，每个变量保存了其本身的数据拷贝（副本），因此在默认情况下，值类型的参数传递不会影响参数本身；而引用类型变量保存了其数据的引用地址，因此以引用方式进行参数传递时会影响到参数本身，因为两个变量会引用了内存中的同一块地址。 
5、值类型有两种表示：装箱与拆箱；引用类型只有装箱一种形式。我会在下节以专门的篇幅来深入讨论这个话题。 
6、典型的值类型为：struct，enum以及大量的内置值类型；而能称为类的都可以说是引用类型。 
7、值类型的内存不由GC（垃圾回收，Gabage Collection）控制，作用域结束时，值类型会自行释放，减少了托管堆的压力，因此具有性能上的优势。例如，通常struct比class更高效；而引用类型的内存回收，由GC来完成，微软甚至建议用户最好不要自行释放内存。 
8、值类型是密封的（sealed），因此值类型不能作为其他任何类型的基类，但是可以单继承或者多继承接口；而引用类型一般都有继承性。 
9、值类型不具有多态性；而引用类型有多态性。 
10、值类型变量不可为null值，值类型都会自行初始化为0值；而引用类型变量默认情况下，创建为null值，表示没有指向任何托管堆的引用地址。对值为null的引用类型的任何操作，都会抛出NullReferenceException异常。 
11、值类型有两种状态：装箱和未装箱，运行库提供了所有值类型的已装箱形式；而引用类型通常只有一种形式：装箱。
值继承 ValueType  引用继承 Object 同时 ValueType 也继承自 Object


二、c#请描述接口与抽象类有什么区别
一、抽象类：
抽象类是特殊的类，只是不能被实例化；除此以外，具有类的其他特性；重要的是抽象类可以包括抽象方法，这是普通类所不能的。抽象方法只能声明于抽象类中，且不包含任何实现，派生类必须覆盖它们。另外，抽象类可以派生自一个抽象类，可以覆盖基类的抽象方法也可以不覆盖，如果不覆盖，则其派生类必须覆盖它们。

二、接口：
接口是引用类型的，类似于类,和抽象类的相似之处有三点：
1、不能实例化；
2、包含未实现的方法声明；
3、派生类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员（不仅是方法包括其他成员）；
另外，接口有如下特性：
接口除了可以包含方法之外，还可以包含属性、索引器、事件，而且这些成员都被定义为公有的。除此之外，不能包含任何其他的成员，例如：常量、域、构造函数、析构函数、静态成员。一个类可以直接继承多个接口，但只能直接继承一个类（包括抽象类）。

三、抽象类和接口的区别：(abstract interface)
1.类是对对象的抽象，可以把抽象类理解为把类当作对象，抽象成的类叫做抽象类.而接口只是一个行为的规范或规定，微软的自定义接口总是后带able字段，证明其是表述一类类“我能做。。。”.抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中. 
2.接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法; 
3.一个类一次可以实现若干个接口,但是只能扩展一个父类 
4.接口可以用于支持回调,而继承并不具备这个特点. 
5.抽象类不能被密封。 
6.抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的. 
7.（接口）与非抽象类类似，抽象类也必须为在该类的基类列表中列出的接口的所有成员提供它自己的实现。但是，允许抽象类将接口方法映射到抽象方法上。 
8.抽象类实现了oop中的一个原则，把可变的与不可变的分离。抽象类和接口就是定义为不可变的，而把可变的座位子类去实现。 
9.好的接口定义应该是具有专一功能性的，而不是多功能的，否则造成接口污染。如果一个类只是实现了这个接口的中一个功能，而不得不去实现接口中的其他方法，就叫接口污染。 
10.尽量避免使用继承来实现组建功能，而是使用黑箱复用，即对象组合。因为继承的层次增多，造成最直接的后果就是当你调用这个类群中某一类，就必须把他们全部加载到栈中！后果可想而知.（结合堆栈原理理解）。同时，有心的朋友可以留意到微软在构建一个类时，很多时候用到了对象组合的方法。比如asp.net中，Page类，有Server Request等属性，但其实他们都是某个类的对象。使用Page类的这个对象来调用另外的类的方法和属性，这个是非常基本的一个设计原则。 
11.如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法.

四、抽象类和接口的使用：
1. 如果预计要创建组件的多个版本，则创建抽象类。抽象类提供简单的方法来控制组件版本。
2.如果创建的功能将在大范围的全异对象间使用，则使用接口。如果要设计小而简练的功能块，则使用接口。
3.如果要设计大的功能单元，则使用抽象类.如果要在组件的所有实现间提供通用的已实现功能，则使用抽象类。 
4.抽象类主要用于关系密切的对象；而接口适合为不相关的类提供通用功能。

以下是我在网上看到的几个形象比喻,真的非常不错,呵呵:
1.飞机会飞，鸟会飞，他们都继承了同一个接口“飞”；但是F22属于飞机抽象类，鸽子属于鸟抽象类。
2. 就像铁门木门都是门（抽象类），你想要个门我给不了（不能实例化），但我可以给你个具体的铁门或木门（多态）；而且只能是门，你不能说它是窗（单继承）；一个门可以有锁（接口）也可以有门铃（多实现）。 门（抽象类）定义了你是什么，接口（锁）规定了你能做什么（一个接口最好只能做一件事，你不能要求锁也能发出声音吧（接口污染））。

三、Unity3D是否支持多线程，如果支持编写时需要注意什么
仅能从主线程中访问Unity3D的组件，对象和Unity3D系统调用
支持：如果同时你要处理很多事情或者与Unity的对象互动小可以用thread,否则使用coroutine。
注意：C#中有lock这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象

http://blog.csdn.net/ywjun0919/article/details/50698692
